---
import { Image } from 'astro:assets'
import { type Time } from '@/lib/utils'

import MechanicSection from '@/components/section/MechanicSection.astro'
import P from '@/components/typography/P.astro'
import Quote from '@/components/typography/Quote.astro'
import RoleIcon from '@/components/RoleIcon.astro'
import SolutionSection from '@/components/section/SolutionSection.astro'
import Span from '@/components/Span.vue'
import StratBoard from '@/components/StratBoard.astro'
import T from '@/components/typography/T.astro'

import img from '@/assets/07/m8s2/tmp.png'
import ResetSVG from '@/assets/svg/reset.svg'
import VideoPlaySVG from '@/assets/svg/video-play.svg'
import CopySVG from '@/assets/svg/copy.svg'

import BareFangsCast from '../_components/BareFangsCast.astro'
import ChampionsCircuitActivate from '../_components/ChampionsCircuitActivate.astro'
import ChampionsCircuitCast from '../_components/ChampionsCircuitCast.astro'
import GleamingFang from '../_components/entities/GleamingFang.astro'

import { translations } from '../_translations'

interface Props {
  start: Time

  activateTimes: Time[]
}

const { start, activateTimes }: Props = Astro.props

const bareFangs = translations.bareFangs
const championsCircuit = translations.championsCircuit

// 伤害参考：
// REF: https://www.fflogs.com/reports/GrMAphvBQfqLT9KJ?fight=4&type=casts&hostility=1&phase=2&view=events
---

<BareFangsCast start={start} />
<ChampionsCircuitCast start="10:11.323" />
<ChampionsCircuitActivate activateTimes={activateTimes} />
<MechanicSection>
  <div class="flex flex-col gap-4">
    <T variant="yellow" text=`${bareFangs}` />
    <P>
      在每个平台生成2个
      <GleamingFang />
      ，每次会有1个
      <GleamingFang />
      展开并对平台释放对应的半场AoE
    </P>
    <T variant="yellow" text=`${championsCircuit}` />
    <P> 读条过程中，各平台出现5种不同但顺序固定的AoE范围提示和旋转提示 </P>
    <P>
      每次攻击判定后，AoE将根据提示进行顺时针或逆时针的旋转，每次旋转
      <Span variant="emerald">72°</Span>
      顺次移动到相邻平台
    </P>
    <Quote variant="cyan"> 注意：读条结束后范围提示和旋转方向都将消失，需要凭借记忆判断安全区 </Quote>

    <P> 上述两种攻击将在每次判定时几乎同时释放 </P>
    <T variant="yellow" text="动态演示" />
    <div class="flex gap-4">
      <div class="flex shrink flex-col items-center gap-4">
        <StratBoard
          width={800}
          height={800}
          key="champions-circuit-mechanic-dynamic"
          class="max-h-120 max-w-120"
          canvasClass="h-full w-full drop-shadow-sm drop-shadow-black"
        />
        <div
          class="flex items-center justify-start gap-2 rounded-full border border-lime-200 bg-lime-100/90 px-3 py-1 backdrop-blur-sm dark:border-lime-800/80 dark:bg-lime-900/80 dark:shadow-lime-900/30"
        >
          <button
            id="champions-circuit-mechanic-dynamic-play-button"
            class="group flex items-center gap-2"
            title="开始演示"
          >
            <div
              class="flex h-6 w-6 items-center justify-center rounded-full bg-lime-500 text-white shadow-inner shadow-lime-400/30 transition-all group-hover:scale-110 group-hover:bg-lime-600 group-hover:shadow group-active:scale-95 dark:bg-lime-600 dark:shadow-lime-500/10 dark:group-hover:bg-lime-500"
            >
              <VideoPlaySVG />
            </div>
            <span
              class="text-sm font-medium text-lime-900 transition-all group-hover:scale-110 group-hover:text-lime-700 group-active:scale-95 dark:text-lime-100 dark:group-hover:text-white"
              >开始演示</span
            >
          </button>
          <span class="mx-0.5 h-5 border-l border-lime-400/80 dark:border-lime-400/60"></span>
          <button id="champions-circuit-mechanic-reset-button" class="group flex items-center gap-2" title="转向并重置">
            <div
              class="flex h-6 w-6 items-center justify-center rounded-full bg-lime-500 text-white shadow-inner shadow-lime-400/30 transition-all group-hover:scale-110 group-hover:bg-lime-600 group-hover:shadow group-active:scale-95 dark:bg-lime-600 dark:shadow-lime-500/10 dark:group-hover:bg-lime-500"
            >
              <ResetSVG />
            </div>
            <span
              class="text-sm font-medium text-lime-900 transition-all group-hover:scale-110 group-hover:text-lime-700 group-active:scale-95 dark:text-lime-100 dark:group-hover:text-white"
              >顺时针</span
            >
            <span class="mx-0.5 h-5 border-l border-lime-400/80 dark:border-lime-400/60"></span>
            <button
              id="champions-circuit-mechanic-copy-button"
              class="group flex items-center gap-2"
              title=`${bareFangs}`
            >
              <div
                class="flex h-6 w-6 items-center justify-center rounded-full bg-lime-500 text-white shadow-inner shadow-lime-400/30 transition-all group-hover:scale-110 group-hover:bg-lime-600 group-hover:shadow group-active:scale-95 dark:bg-lime-600 dark:shadow-lime-500/10 dark:group-hover:bg-lime-500"
              >
                <CopySVG class="flex h-4 w-4" />
              </div>
              <span
                class="text-sm font-medium text-lime-900 transition-all group-hover:scale-110 group-hover:text-lime-700 group-active:scale-95 dark:text-lime-100 dark:group-hover:text-white"
                >{bareFangs}</span
              >
            </button>
          </button>
        </div>
      </div>
    </div>
  </div>
</MechanicSection>
<SolutionSection>
  <div class="flex flex-col gap-4">
    <P> 待补充 </P>
    <P>
      <RoleIcon role="all" tag="全员" />
      在初始平台中线位置集合，便于后续移动到安全区
    </P>
  </div>
</SolutionSection>

<script>
  import type { Application, Ticker } from 'pixi.js'

  import { animate } from 'motion'
  import { listenKeys } from 'nanostores'
  import { Assets, Container, Graphics, Sprite } from 'pixi.js'

  import inactiveFang_img from '@/assets/07/m8s2/entity_icons/gleaming_fang_1@4x.png'
  import preparedFang_img from '@/assets/07/m8s2/entity_icons/gleaming_fang_2@4x.png'
  import activeFang_img from '@/assets/07/m8s2/entity_icons/gleaming_fang_4@4x.png'
  import floor_img from '@/assets/07/m8s2/p2/floor_2@3x.png'
  import { AoE, AoETexture } from '@/pixi/aoe'
  import { DEFAULT_AOE_RESOLUTION } from '@/pixi/resolutions'
  import { getScale, YmToPx } from '@/pixi/utils'
  import { $stratBoards } from '@/stores/stratBoards'

  import { Fang, FangPair } from '../_fangs'

  const centerDistance = 17.54
  const scaleSize = 1.25
  const YmToPxLarge = YmToPx * scaleSize

  // champions circuit position
  const aoePos: { r: number; rad: number }[] = [
    { r: centerDistance * YmToPxLarge, rad: Math.PI / 10 },
    { r: centerDistance * YmToPxLarge, rad: Math.PI / 2 },
    { r: centerDistance * YmToPxLarge, rad: (9 * Math.PI) / 10 },
    { r: centerDistance * YmToPxLarge, rad: (-7 * Math.PI) / 10 },
    { r: centerDistance * YmToPxLarge, rad: (-3 * Math.PI) / 10 },
  ]

  function polarRadianToCartesian(ppos: { r: number; rad: number }): { x: number; y: number } {
    const x = ppos.r * Math.cos(ppos.rad)
    const y = ppos.r * Math.sin(ppos.rad)
    return { x, y }
  }

  function getPatternArr(): (0 | 1)[] {
    return Array.from({ length: 5 }, () => (Math.random() > 0.5 ? 1 : 0) as 0 | 1)
  }

  function rotateArray<T>(arr: T[], offset: number = 1) {
    const len = arr.length
    const n = ((offset % len) + len) % len
    return arr.slice(n).concat(arr.slice(0, n))
  }

  function maskedAoEToSprite(app: Application, aoe: Sprite, mask?: Graphics): Sprite {
    const container = new Container()
    container.position.set(0)

    if (mask) {
      aoe.mask = mask
      container.addChild(mask)
    }
    container.addChild(aoe)

    const texture = new AoETexture(app.renderer.extract.texture(container), 'circle', DEFAULT_AOE_RESOLUTION)
    const sprite = Sprite.from(texture)
    const centerPivot = texture.getCenterPivot()
    sprite.pivot.set(centerPivot.x, centerPivot.y)

    container.destroy({ children: true, texture: true, textureSource: true })

    return sprite
  }

  function generateChampionsCircuitAoes(
    app: Application,
    aoePos: { r: number; rad: number }[],
    scale: number = scaleSize,
  ): Sprite[] {
    // aoe ring
    const aoeSmallRingSprite = AoE.createRing(4.5 * scale, 13 * scale).toSprite(app)
    const aoeSmallRing = maskedAoEToSprite(app, aoeSmallRingSprite)

    // aoe rect
    const aoeRectSprite = AoE.createRect(12 * scale, 20 * scale).toSprite(app)
    aoeRectSprite.rotation = Math.PI / 2
    const aoeRectMask = new Graphics().circle(0, 0, 8 * YmToPxLarge).fill({ color: 'white' })
    const aoeRect = maskedAoEToSprite(app, aoeRectSprite, aoeRectMask)

    // aoe large circle
    const pos = polarRadianToCartesian({ r: aoePos[0].r, rad: Math.PI })
    const aoeCircleFanSprite = AoE.createCircle(22 * scale).toSprite(app)
    aoeCircleFanSprite.rotation = aoePos[0].rad
    aoeCircleFanSprite.position.set(0, 0)
    const aoeCircleFanMask = new Graphics().circle(-pos.x, pos.y, 8 * YmToPxLarge).fill({ color: 'white' })
    const aoeCircleFan = maskedAoEToSprite(app, aoeCircleFanSprite, aoeCircleFanMask)

    // aoe large ring fan * 2
    const aoeRingFan1Sprite = AoE.createRingFan(15 * scale, 26 * scale, 60).toSprite(app)
    const aoeRingFan1 = maskedAoEToSprite(app, aoeRingFan1Sprite)

    const aoeRingFan2Sprite = AoE.createRingFan(15 * scale, 26 * scale, 60).toSprite(app)
    const aoeRingFan2 = maskedAoEToSprite(app, aoeRingFan2Sprite)

    return [aoeSmallRing, aoeRect, aoeRingFan1, aoeCircleFan, aoeRingFan2]
  }

  function generateAoeConfigs(pos: { r: number; rad: number }[]): {
    position: { x: number; y: number }
    rotation: number
  }[] {
    // 默认顺序对应Ring，Rect，RingFan1，CircleFan，RingFan2
    const pos0 = polarRadianToCartesian(pos[0])
    const pos1 = polarRadianToCartesian(pos[1])
    const pos2 = polarRadianToCartesian({ r: 20.5 * YmToPxLarge, rad: pos[2].rad })

    const pos3 = polarRadianToCartesian(pos[3])
    const pos4 = polarRadianToCartesian({ r: 20.5 * YmToPxLarge, rad: pos[4].rad })

    return [
      { position: pos0, rotation: pos[0].rad },
      { position: pos1, rotation: pos[1].rad },
      { position: pos2, rotation: pos[2].rad },
      { position: pos3, rotation: pos[3].rad },
      { position: pos4, rotation: pos[4].rad },
    ]
  }

  function placeChampionsCircuitAoes(
    aoeSprites: Sprite[],
    aoeConifg: {
      position: { x: number; y: number }
      rotation: number
    }[],
  ) {
    aoeSprites.forEach((sprite, i) => {
      sprite.position.set(aoeConifg[i].position.x, aoeConifg[i].position.y)
      sprite.rotation = aoeConifg[i].rotation
    })
  }

  async function fadeInAoes(container: Container, aoeSprites: Sprite[], duration = 0.1): Promise<void> {
    aoeSprites.forEach((sprite) => {
      sprite.alpha = 0
      container.addChild(sprite)
    })

    const animations = aoeSprites.map((sprite) => animate(sprite, { alpha: 1 }, { duration }))

    return Promise.all(animations.map((a) => a.finished)).then(() => {})
  }

  async function fadeOutAoes(container: Container, aoeSprites: Sprite[], duration = 0.1): Promise<void> {
    const animations = aoeSprites.map((sprite) =>
      animate(sprite, { alpha: 0 }, { duration }).finished.then(() => {
        container.removeChild(sprite)
      }),
    )

    return Promise.all(animations).then(() => {})
  }

  listenKeys($stratBoards, ['champions-circuit-mechanic-dynamic'], async (stratBoards) => {
    const app = stratBoards['champions-circuit-mechanic-dynamic']

    const container = new Container()
    container.position.set(app.screen.width / 2, app.screen.height / 2)
    app.stage.addChild(container)

    const floorTexture = await Assets.load(floor_img)
    const floor = Sprite.from(floorTexture)
    const centerToNorth = 17.54 * Math.cos(Math.PI / 5) + 8
    const centerToSouth = 17.54 + 8
    floor.anchor.set(0.5, centerToNorth / (centerToNorth + centerToSouth))
    floor.scale.set(getScale() * 1.25)
    container.addChild(floor)

    // Champion's Circuit
    const randStart = Math.floor(Math.random() * 5)
    const aoeContainer = new Container()
    container.addChild(aoeContainer)

    const aoeSprites: Sprite[] = generateChampionsCircuitAoes(app, aoePos)
    placeChampionsCircuitAoes(aoeSprites, generateAoeConfigs(rotateArray(aoePos, randStart)))
    void fadeInAoes(aoeContainer, aoeSprites)

    // Bare Fangs
    const fangsContainer = new Container()
    container.addChild(fangsContainer)

    const inactiveFang = await Assets.load(inactiveFang_img)
    const fangPairs: FangPair[] = Array.from({ length: 5 }, (_, i) => {
      const left = new Fang(app, inactiveFang, { pattern: 1, rotate: i as 0 | 1 | 2 | 3 | 4 })
      const right = new Fang(app, inactiveFang, { rotate: i as 0 | 1 | 2 | 3 | 4 })
      return new FangPair(left, right)
    })
    fangPairs.forEach((p) => p.loadPair(fangsContainer))

    // dyanmic
    const interval = 4400
    let exampleDisplay = false
    let firstPlay = true
    let activeTriggered = false
    let inactiveTriggered = false
    let preparedTriggered = false
    let rotateDir = 1
    let offset = randStart // 控制回天动地的旋转方向，+1为顺时针
    let patternArr: (0 | 1)[] = [] // 选择每组光牙的激活半侧
    let tickerFn: ((ticker: Ticker) => void) | null = null

    async function loadRestObjects(fangPairs: FangPair[]) {
      // Bare Fangs
      const [activeFang, preparedFang] = await Promise.all([Assets.load(activeFang_img), Assets.load(preparedFang_img)])
      fangPairs.forEach((pair, i) => {
        if (!pair.hasAllState()) {
          const prepared = new Fang(app, preparedFang, { rotate: i as 0 | 1 | 2 | 3 | 4 })
          const active = new Fang(app, activeFang, { activate: true, rotate: i as 0 | 1 | 2 | 3 | 4 })
          pair.addRemainingFangs(prepared, active)
        }
      })
    }

    async function play() {
      let elapsed = 0

      await loadRestObjects(fangPairs)

      if (tickerFn) {
        app.ticker.remove(tickerFn)
        tickerFn = null
      }

      tickerFn = async (ticker) => {
        elapsed += ticker.elapsedMS

        if (!inactiveTriggered && elapsed >= interval / 3) {
          inactiveTriggered = true

          patternArr = getPatternArr()

          if (firstPlay) {
            aoeContainer.removeChildren()
            aoeContainer.addChild(...aoeSprites)
            fangsContainer.removeChildren()
            fangPairs.forEach((p) => p.loadPair(fangsContainer))
          } else {
            void fadeOutAoes(aoeContainer, aoeSprites)
            await Promise.all(fangPairs.map((p) => p.fadeOutPair(fangsContainer)))
            await Promise.all(fangPairs.map((p) => p.fadeInPair(fangsContainer)))
          }

          placeChampionsCircuitAoes(aoeSprites, generateAoeConfigs(rotateArray(aoePos, offset)))
          fangPairs.forEach((p, i) => p.switchSide(patternArr[i]))
        }

        if (!preparedTriggered && elapsed >= (2 * interval) / 3) {
          preparedTriggered = true

          if (firstPlay) {
            firstPlay = false
          } else {
            void fadeOutAoes(aoeContainer, aoeSprites)
          }

          await Promise.all(fangPairs.map((p) => p.fadeOutPair(fangsContainer)))
          await Promise.all(fangPairs.map((p) => p.fadeInPair(fangsContainer, 'prepared')))
        }

        if (!activeTriggered && elapsed >= interval) {
          activeTriggered = true
          offset += rotateDir // +1为顺时针

          void fadeInAoes(aoeContainer, aoeSprites)

          await Promise.all(fangPairs.map((p) => p.fadeOutPair(fangsContainer)))
          await Promise.all(fangPairs.map((p) => p.fadeInPair(fangsContainer, 'active')))
        }

        if (elapsed >= interval) {
          elapsed = 0
          preparedTriggered = false
          activeTriggered = false
          inactiveTriggered = false
        }
      }

      app.ticker.add(tickerFn)
    }

    async function reset() {
      firstPlay = true
      if (tickerFn) {
        app.ticker.remove(tickerFn)
        tickerFn = null
      }

      rotateDir = -rotateDir
      // 更新按钮文字
      const span = document.querySelector('#champions-circuit-mechanic-reset-button span')
      if (span) {
        span.textContent = rotateDir > 0 ? '顺时针' : '逆时针'
      }

      aoeContainer.removeChildren()
      offset = Math.floor(Math.random() * 5)
      placeChampionsCircuitAoes(aoeSprites, generateAoeConfigs(rotateArray(aoePos, offset)))
      await fadeInAoes(aoeContainer, aoeSprites)

      fangsContainer.removeChildren()
      await Promise.all(fangPairs.map((p) => p.fadeInPair(fangsContainer)))
    }

    async function example() {
      firstPlay = true
      if (tickerFn) {
        app.ticker.remove(tickerFn)
        tickerFn = null
      }

      if (exampleDisplay) {
        exampleDisplay = false

        await Promise.all(fangPairs.map((p) => p.fadeOutPair(fangsContainer)))
        await Promise.all(fangPairs.map((p) => p.fadeInPair(fangsContainer)))

        return
      }

      exampleDisplay = true
      await loadRestObjects(fangPairs)

      aoeContainer.removeChildren()
      void fadeInAoes(aoeContainer, aoeSprites)

      patternArr = getPatternArr()
      fangsContainer.removeChildren()
      fangPairs.forEach((p, i) => {
        p.switchSide(patternArr[i]).fadeInPair(fangsContainer, 'active')
      })
    }

    document.getElementById('champions-circuit-mechanic-dynamic-play-button')?.addEventListener('click', () => {
      play()
    })

    document.getElementById('champions-circuit-mechanic-reset-button')?.addEventListener('click', () => {
      reset()
    })

    document.getElementById('champions-circuit-mechanic-copy-button')?.addEventListener('click', () => {
      example()
    })
  })
</script>
